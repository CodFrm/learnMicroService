> 微服务架构中,每个微服务所拥有的数据对当前微服务来说是私有的,只能通过其提供的 API 进行访问.我们需要实现业务的事务在多个服务之间保持一致性,还有就是不同服务中数据的数据聚合.

## 方案
这一节将来探究不同的微服务之间,不同服务中数据的数据聚合.我将列出几种方法.

### 字段冗余
这一种方法是在查询的表中增加一些字段存储另外一些表的数据,这种方法实现起来比较方便,但是需要改变表结构,而且如果所需要的字段比较多,这又会出现不少问题.

### 业务中合并
通过调用所需要的微服务接口得到数据,使用代码将数据合并起来,达到join的效果.这种方法虽然对数据库没有什么影响,而且也符合微服务的思想,但是性能损耗过大.

### 数据库FEDERATED引擎
MySQL数据库能够使用FEDERATED引擎映射所需要的表,有点像复制但并不是的,然后可以使用join查询达到我们想要的效果.这个也许是一个不错的解决方案,但是不符合我们微服务的设计思想,不易于独立交付,对方微服务表结构修改之后可能会出现问题.

### 共享数据库
将需要join的数据表放在同一个数据库上,其余的还是作为独立的数据库.感觉优缺点和上面差不多.

### CQRS架构
命令查询的责任分离Command Query Responsibility Segregation (简称CQRS)模式是一种架构体系模式，能够使改变模型的状态的命令和模型状态的查询实现分离。这是微服务跨数据库查询的一个比较流行的解决方案,具体怎么样我也不细说了,怕误人子弟![](img/bqb_3.jpg)

## 事件驱动架构(EDA)
> 这也是一个比较流行的解决方案,我们将基于这一套架构来实现我们的功能.

CQRS使用了EDA的思想,所以感觉起来非常的相似,哪里不同我现在也说不出来....它们实现不同服务数据聚合的方式都是维护一个**物化视图**,这两个架构也可以实现**分布式事务**,具体的下一节分解.

### 物化视图
视图就是使用基于select和join来创建的,平常我们联合查询的时候得出的结果就可以当做是一个视图,相当于是一张虚拟表,但是实际的数据还是在其它的表上面.然后这里的物化视图是指的将实际的数据合并到一张表上去(也并不一定指表,如果你用nosql的话),这也是一种优化数据库查询的方法,mysql没有物化视图,oracle有.

### 维护视图
要使用EDA来维护我们微服务使用的物化视图.

我现在的思路是这样的(现在我们的发帖和权限两个微服务来说),使用kafka作为消息中间件,发布事件.

当发帖的时候发布一个user_post消息,然后订阅这个消息,物化视图插入一条数据(其实感觉发帖不需要发布事件,因为我们维护的这个物化视图就是供发帖微服务使用的,使用的话是用于解耦).

用户改名的时候发布一条user_update_msg消息,然后订阅这个消息,修改物化视图中的用户名.(我们将输出的信息包括了,用户名,帖子标题)

然后如果之前的数据迁移的话,我想的是创建视图表的时候,使用微服务api(或者直接将数据复制过来进行操作),在代码中聚合数据,将数据插入物化视图,不知道这是不是一个可行的方法.

这一切都是一个菜鸡的尝试...如果不正确希望能够得到指教.

### 实现
依旧使用docker来搭建我们的mq,由于Kafka的基于集群的高可用特性是建基于Zookeeper（称zk）之上的,因此构建可用的Kafka镜像,是需要依赖于zk基础的.
```yaml
    zookeeper:
        image: wurstmeister/zookeeper
        hostname: zookeeper
        container_name: micro_zookeeper
        ports:
            - 2181:2181
        networks: 
            - micro

    kafka:
        image: wurstmeister/kafka
        hostname: kafka_mq
        container_name: micro_kafka_mq
        environment: 
            - KAFKA_ADVERTISED_HOST_NAME=10.0.75.1
            - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
        ports:
            - 9092:9092
        networks: 
            - micro

    kafka_manager:
        image: sheepkiller/kafka-manager
        container_name: micro_kafka_manager
        environment:
            - ZK_HOSTS=zookeeper
        ports:  
            - 9000:9000
        networks: 
            - micro
```
9000端口是kafka的一个web管理,后来感觉不好用...我用了一个桌面的程序,kafka tools

kafka还有挺多概念的,这里的话我就不细说了.我在examples下写了一个demo,大家可以去看看,效果如下,大概模拟的多个微服务(群组1和群组2为两个微服务)消费一条事件(不能重复消费,然后分布到不同的微服务实例上)
![](img/6_1.png)

